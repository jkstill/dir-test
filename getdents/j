00001 #include <stdio.h>
00002 #include <pwd.h>
00003 #include <grp.h>
00004 #include <time.h>
00005 #include <stdlib.h>
00006 #include <string.h>
00007 #include <assert.h>
00008 #include <unistd.h>
00009 #include <time.h>
00010 #include <sys/time.h>
00011 #include <errno.h>
00012 #include <linux/types.h>
00013 #include <linux/dirent.h>
00014 #include <linux/unistd.h>
00015 #include <limits.h>
00016 #include <sys/stat.h>
00017 #include <fcntl.h>
00018 #include <sys/types.h>
00019 #include <sys/stat.h>
00020 #include "quicklist.h"
00021 #define ERR_MAX 256
00022 
00023 #define S_SLITE_SIZET     0x1
00024 #define S_SLITE_BLKSIZE   0x2
00025 #define S_SLITE_BLOCKS    0x4
00026 #define S_SLITE_ATIME     0x8
00027 #define S_SLITE_MTIME     0x10
00028 #define S_SLITE_CTIME     0x20
00029 #define S_SLITE_ALL       (S_SLITE_SIZET | S_SLITE_BLKSIZE | S_SLITE_BLOCKS \
00030                                                                         S_SLITE_ATIME | S_SLITE_MTIME   | S_SLITE_CTIME)
00031 
00032 #define SLITE_SIZET(m)    ((m) & S_SLITE_SIZET)
00033 #define SLITE_BLKSIZE(m)  ((m) & S_SLITE_BLKSIZE)
00034 #define SLITE_BLOCKS(m)   ((m) & S_SLITE_BLOCKS)
00035 #define SLITE_ATIME(m)    ((m) & S_SLITE_ATIME)
00036 #define SLITE_MTIME(m)    ((m) & S_SLITE_MTIME)
00037 #define SLITE_CTIME(m)    ((m) & S_SLITE_CTIME)
00038 
00039 
00040 static int dirent_granularity = 4096;
00041 static int use_direntplus = 0;
00042 static int recurse = 0;
00043 static int use_lite = 0;
00044 /* whether to use 64 bit calls or 32 bit ones */
00045 static int use_64 = 0;
00046 static char path[256] = ".";
00047 static int nlevels = 0, nobjects = 0, verbose = 0;
00048 
00049 #if defined(__i386__) || defined(__i486__) || defined(__i586__) || defined(__i686__)
00050 /* FIXME:
00051  * PLEASE CHANGE THIS SYSTEM
00052  * CALL NUMBER IN CASE YOUR
00053  * ARCHITECTURE IS NOT IA-32 
00054  * OR IF YOUR KERNEL SYSCALL NUMBERS
00055  * ARE DIFFERENT. YOU HAVE BEEN WARNED!!!!!
00056  */
00057 #define __NR_newstatlite 313
00058 #define __NR_newlstatlite 314
00059 #define __NR_newfstatlite 315
00060 
00061 #define __NR_getdents_plus 319
00062 #define __NR_getdents64_plus 320
00063 
00064 #define __NR_getdents_plus_lite 323
00065 #define __NR_getdents64_plus_lite 324
00066 
00067 /* kernel's version of stat is different from glibc stat */
00068 struct kernel_stat {
00069         unsigned long  st_dev;
00070         unsigned long  st_ino;
00071         unsigned short st_mode;
00072         unsigned short st_nlink;
00073         unsigned short st_uid;
00074         unsigned short st_gid;
00075         unsigned long  st_rdev;
00076         unsigned long  st_size;
00077         unsigned long  st_blksize;
00078         unsigned long  st_blocks;
00079         unsigned long  st_atim;
00080         unsigned long  st_atim_nsec;
00081         unsigned long  st_mtim;
00082         unsigned long  st_mtim_nsec;
00083         unsigned long  st_ctim;
00084         unsigned long  st_ctim_nsec;
00085         unsigned long  __unused4;
00086         unsigned long  __unused5;
00087 };
00088 
00089 struct kernel_stat_lite {
00090         unsigned long  st_dev;
00091         unsigned long  st_ino;
00092         unsigned short st_mode;
00093         unsigned short st_nlink;
00094         unsigned short st_uid;
00095         unsigned short st_gid;
00096         unsigned long  st_rdev;
00097         unsigned long  st_litemask;
00098         unsigned long  st_size;
00099         unsigned long  st_blksize;
00100         unsigned long  st_blocks;
00101         unsigned long  st_atim;
00102         unsigned long  st_atime_nsec;
00103         unsigned long  st_mtim;
00104         unsigned long  st_mtime_nsec;
00105         unsigned long  st_ctim;
00106         unsigned long  st_ctime_nsec;
00107         unsigned long  __unused4;
00108         unsigned long  __unused5;
00109 };
00110 
00111 struct stat64_lite {
00112         unsigned long long      st_dev;
00113         unsigned char   __pad0[4];
00114         unsigned long   __st_ino;
00115         unsigned int    st_mode;
00116         unsigned int    st_nlink;
00117         unsigned long   st_uid;
00118         unsigned long   st_gid;
00119         unsigned long long      st_rdev;
00120         unsigned char   __pad3[4];
00121         unsigned long  st_litemask;
00122         unsigned char  __pad5[4];
00123         long long       st_size;
00124         unsigned long   st_blksize;
00125         unsigned long   st_blocks;      /* Number 512-byte blocks allocated. */
00126         unsigned long   __pad4;         /* future possible st_blocks high bits */
00127         unsigned long   st_atim;
00128         unsigned long   st_atim_nsec;
00129         unsigned long   st_mtim;
00130         unsigned int    st_mtim_nsec;
00131         unsigned long   st_ctim;
00132         unsigned long   st_ctim_nsec;
00133         unsigned long long      st_ino;
00134 };
00135 
00136 /* stat64 of kernel matches stat64 of glibc! hence we could stick with the same */
00137 struct dirent64_plus {
00138         struct stat64   dp_stat;
00139         int             dp_stat_err;
00140         struct dirent64 dp_dirent;
00141 };
00142 
00143 struct dirent64_plus_lite {
00144         struct stat64_lite   dp_stat_lite;
00145         int                  dp_stat_lite_err;
00146         struct dirent64            dp_dirent;
00147 };
00148 
00149 #elif defined (x86_64) || defined (__x86_64__)
00150 
00151 #define __NR_newstatlite   275
00152 #define __NR_newlstatlite  276
00153 #define __NR_newfstatlite  277
00154 
00155 #define __NR_getdents_plus 278
00156 #define __NR_getdents64_plus 279
00157 
00158 #define __NR_getdents_plus_lite 282
00159 #define __NR_getdents64_plus_lite 283
00160 
00161 /* kernel's version of stat could be different from glibc stat */
00162 struct kernel_stat {
00163         unsigned long   st_dev;
00164         unsigned long   st_ino;
00165         unsigned long   st_nlink;
00166 
00167         unsigned int    st_mode;
00168         unsigned int    st_uid;
00169         unsigned int    st_gid;
00170         unsigned int    __pad0;
00171         unsigned long   st_rdev;
00172         long            st_size;
00173         long            st_blksize;
00174         long            st_blocks;      /* Number 512-byte blocks allocated. */
00175         unsigned long   st_atim;
00176         unsigned long   st_atim_nsec; 
00177         unsigned long   st_mtim;
00178         unsigned long   st_mtim_nsec;
00179         unsigned long   st_ctim;
00180         unsigned long   st_ctim_nsec;
00181         long            __unused[3];
00182 };
00183 
00184 struct kernel_stat_lite {
00185         unsigned long   st_dev;
00186         unsigned long   st_ino;
00187         unsigned long   st_nlink;
00188         unsigned int    st_mode;
00189         unsigned int    st_uid;
00190         unsigned int    st_gid;
00191         unsigned int    __pad0;
00192         unsigned long   st_rdev;
00193         unsigned long  st_litemask;
00194         long            st_size;
00195         long            st_blksize;
00196         long            st_blocks;      /* Number 512-byte blocks allocated. */
00197         unsigned long   st_atim;
00198         unsigned long   st_atime_nsec; 
00199         unsigned long   st_mtim;
00200         unsigned long   st_mtime_nsec;
00201         unsigned long   st_ctim;
00202         unsigned long   st_ctime_nsec;
00203         long            __unused[3];
00204 };
00205 
00206 #define stat64_lite kernel_stat_lite
00207 
00208 /* stat64 of kernel is the same as kernel_stat on opteron 64 */
00209 struct dirent64_plus {
00210         struct kernel_stat   dp_stat;
00211         int             dp_stat_err;
00212         struct dirent64 dp_dirent;
00213 };
00214 
00215 struct dirent64_plus_lite {
00216         struct kernel_stat_lite dp_stat_lite;
00217         int              dp_stat_lite_err;
00218         struct dirent64  dp_dirent;
00219 };
00220 
00221 #endif
00222 
00223 struct dirent_plus {
00224         struct kernel_stat   dp_stat;
00225         int           dp_stat_err;
00226         struct dirent dp_dirent;
00227 };
00228 
00229 struct dirent_plus_lite {
00230         struct kernel_stat_lite dp_stat_lite;
00231         int              dp_stat_lite_err;
00232         struct dirent    dp_dirent;
00233 };
00234 
00235 static QLIST_HEAD(TREE);
00236 
00237 /* Information about each file in the hierarchy */
00238 struct files {
00239         /* Full path name of the file */
00240         char                                                                    name[PATH_MAX];
00241         /* inode number of the file   */
00242         int64_t                                                                 inode;
00243         int visited;
00244         /* The level field is used to link struct files both in the tree and in the flist */
00245         struct qlist_head                                       level; 
00246 };
00247 
00248 static inline struct files* clone_filp(struct files *filp)
00249 {
00250         struct files *new_filp = (struct files *)calloc(1, sizeof(struct files));
00251         if (new_filp) {
00252                 memcpy(new_filp, filp, sizeof(*filp));
00253                 /* Reset next and prev to NULL */
00254                 new_filp->level.next = new_filp->level.prev = NULL;
00255         }
00256         return new_filp;
00257 }
00258 
00259 /* the _syscallXX apprroach is not portable. instead, we'll use syscall and
00260  * sadly forego any type checking.  For reference, here are the prototypes for
00261  * the system calls 
00262 int newstatlite(const char *, struct kernel_stat_lite *);
00263 static int newfstatlite(int, struct kernel_stat_lite *);
00264 static int newlstatlite(const char *, struct kernel_stat_lite *);
00265 static int getdents(uint, struct dirent *, uint);
00266 static int getdents64(uint, struct dirent64 *, uint);
00267 static int getdents_plus(uint, struct dirent_plus *, uint);
00268 static int getdents64_plus(uint, struct dirent64_plus *, uint);
00269 static int getdents_plus_lite(unsigned int fd, unsigned long lite_mask,
00270                                 struct dirent_plus_lite *dirent, unsigned int count);
00271 static int getdents64_plus_lite(unsigned int fd, unsigned long lite_mask,
00272                                 struct dirent64_plus_lite *dirent, unsigned int count);
00273 */
00274 
00275 
00276 /* free the struct files queued on the TREE list */
00277 
00278 static void dealloc_treelist(void)
00279 {
00280         while (TREE.next != &TREE) {
00281                 struct files *filp;
00282 
00283                 filp = qlist_entry(TREE.next, struct files, level);
00284                 qlist_del(TREE.next);
00285                 free(filp);
00286         }
00287         return;
00288 }
00289 
00290 /*
00291  * NOTES: Since we want BREADTH-FIRST TRAVERSAL, we build a link list(queue).
00292  * If we wanted DEPTH-FIRST TRAVERSAL, then we need to build a stack here, i.e
00293  * we need to use qlist_add() function instead of qlist_add_tail()
00294  */
00295 
00296 static int path_init(const char *path)
00297 {
00298         struct files *filp = NULL;
00299 
00300         filp = (struct files *)calloc(1, sizeof(struct files));
00301         if (!filp) {
00302                 perror("do_root:calloc");
00303                 return -1;
00304         }
00305         snprintf(filp->name, NAME_MAX + 1, "%s", path);
00306         /* add it to the tree of to-be visited nodes */
00307         qlist_add_tail(&filp->level, &TREE);
00308         filp->visited = 1;
00309         return 0;
00310 }
00311 
00312 /*
00313   build a string of a specified length that's either
00314   left or right justified based on the src string;
00315   caller must free ptr passed out as *out_str_p
00316 */
00317 static inline void format_size_string(
00318     char *src_str, int num_spaces_total, char **out_str_p,
00319     int right_justified, int hard_limit)
00320 {
00321     int len = 0;
00322     int spaces_size_allowed = 0;
00323     char *buf = NULL, *start = NULL, *src_start = NULL;
00324 
00325     assert(src_str);
00326     len = strlen(src_str);
00327 
00328     if (hard_limit)
00329     {
00330         spaces_size_allowed = (num_spaces_total ? num_spaces_total : len);
00331     }
00332     else
00333     {
00334         spaces_size_allowed = len;
00335         if (len < num_spaces_total)
00336         {
00337             spaces_size_allowed = num_spaces_total;
00338         }
00339     }
00340         
00341     buf = (char *)malloc(spaces_size_allowed+1);
00342     assert(buf);
00343 
00344     memset(buf,0,spaces_size_allowed+1);
00345 
00346     if ((len > 0) && (len <= spaces_size_allowed))
00347     {
00348         memset(buf,' ',(spaces_size_allowed));
00349 
00350         src_start = src_str;
00351 
00352         if (right_justified)
00353         {
00354             start = &buf[(spaces_size_allowed-(len))];
00355         }
00356         else
00357         {
00358             start = buf;
00359         }
00360 
00361         while(src_start && (*src_start))
00362         {
00363             *start++ = *src_start++;
00364         }
00365         *out_str_p = strdup(buf);
00366     }
00367     else if (len > 0)
00368     {
00369         /* if the string is too long, don't format it */
00370         *out_str_p = strdup(src_str);
00371     }
00372     else if (len == 0)
00373     {
00374         *out_str_p = strdup("");
00375     }
00376     free(buf);
00377 }
00378 
00379 static void print_entry_stat64(
00380     char *entry_name,
00381     struct stat64 *attr,
00382          const char *link_target)
00383 {
00384     char buf[128] = {0}, *formatted_size = NULL;
00385     char *formatted_owner = NULL, *formatted_group = NULL;
00386     struct group *grp = NULL;
00387     struct passwd *pwd = NULL;
00388     char *empty_str = "";
00389     char *owner = empty_str, *group = empty_str;
00390     char *inode = empty_str;
00391     time_t mtime = (time_t)attr->st_mtime;
00392     struct tm *time = localtime(&mtime);
00393     unsigned long size = 0;
00394     char scratch_owner[16] = {0}, scratch_group[16] = {0};
00395     char scratch_size[16] = {0};
00396     char f_type = '-';
00397     char group_x_char = '-';
00398 
00399     if (attr == NULL)
00400     {
00401         return;
00402     }
00403 
00404     snprintf(scratch_owner,16,"%d",(int)attr->st_uid);
00405     snprintf(scratch_group,16,"%d",(int)attr->st_gid);
00406 
00407     if (S_ISREG(attr->st_mode))
00408     {
00409         size = attr->st_size;
00410     }
00411     else if (S_ISLNK(attr->st_mode))
00412     {
00413         size = 0;
00414     }
00415     else if (S_ISDIR(attr->st_mode))
00416     {
00417         size = 4096;
00418     }
00419 
00420           snprintf(scratch_size,16, "%ld", size);
00421     format_size_string(scratch_size,11,&formatted_size,1,1);
00422 
00423           owner = scratch_owner;
00424           group = scratch_group;
00425 
00426             pwd = getpwuid((uid_t)attr->st_uid);
00427             owner = (pwd ? pwd->pw_name : scratch_owner);
00428             grp = getgrgid((gid_t)attr->st_gid);
00429             group = (grp ? grp->gr_name : scratch_group);
00430 
00431     /* for owner and group allow the fields to grow larger than 8 if
00432      * necessary (set hard_limit to 0), but pad anything smaller to
00433      * take up 8 spaces.
00434      */
00435     format_size_string(owner,8,&formatted_owner,0,0);
00436     format_size_string(group,8,&formatted_group,0,0);
00437 
00438     if (S_ISDIR(attr->st_mode))
00439     {
00440         f_type =  'd';
00441     }
00442     else if (S_ISLNK(attr->st_mode))
00443     {
00444         f_type =  'l';
00445     }
00446 
00447          if (link_target == NULL)
00448     snprintf(buf,128,"%s%c%c%c%c%c%c%c%c%c%c    1 %s %s %s "
00449              "%.4d-%.2d-%.2d %.2d:%.2d %s",
00450              inode,
00451              f_type,
00452              ((attr->st_mode & S_IRUSR) ? 'r' : '-'),
00453              ((attr->st_mode & S_IWUSR) ? 'w' : '-'),
00454              ((attr->st_mode & S_IXUSR) ? 'x' : '-'),
00455              ((attr->st_mode & S_IRGRP) ? 'r' : '-'),
00456              ((attr->st_mode & S_IWGRP) ? 'w' : '-'),
00457              group_x_char,
00458              ((attr->st_mode & S_IROTH) ? 'r' : '-'),
00459              ((attr->st_mode & S_IWOTH) ? 'w' : '-'),
00460              ((attr->st_mode & S_IXOTH) ? 'x' : '-'),
00461              formatted_owner,
00462              formatted_group,
00463              formatted_size,
00464              (time->tm_year + 1900),
00465              (time->tm_mon + 1),
00466              time->tm_mday,
00467              (time->tm_hour),
00468              (time->tm_min),
00469              entry_name);
00470          else 
00471                  snprintf(buf,128,"%s%c%c%c%c%c%c%c%c%c%c    1 %s %s %s "
00472                                          "%.4d-%.2d-%.2d %.2d:%.2d %s -> %s",
00473                                          inode,
00474                                          f_type,
00475                                          ((attr->st_mode & S_IRUSR) ? 'r' : '-'),
00476                                          ((attr->st_mode & S_IWUSR) ? 'w' : '-'),
00477                                          ((attr->st_mode & S_IXUSR) ? 'x' : '-'),
00478                                          ((attr->st_mode & S_IRGRP) ? 'r' : '-'),
00479                                          ((attr->st_mode & S_IWGRP) ? 'w' : '-'),
00480                                          group_x_char,
00481                                          ((attr->st_mode & S_IROTH) ? 'r' : '-'),
00482                                          ((attr->st_mode & S_IWOTH) ? 'w' : '-'),
00483                                          ((attr->st_mode & S_IXOTH) ? 'x' : '-'),
00484                                          formatted_owner,
00485                                          formatted_group,
00486                                          formatted_size,
00487                                          (time->tm_year + 1900),
00488                                          (time->tm_mon + 1),
00489                                          time->tm_mday,
00490                                          (time->tm_hour),
00491                                          (time->tm_min),
00492                                          entry_name, link_target);
00493 
00494 
00495     if (formatted_size)
00496     {
00497         free(formatted_size);
00498     }
00499     if (formatted_owner)
00500     {
00501         free(formatted_owner);
00502     }
00503     if (formatted_group)
00504     {
00505         free(formatted_group);
00506     }
00507          if ((use_direntplus == 0 && f_type != 'd') || use_direntplus != 0)
00508                           nobjects++;
00509         if (verbose)
00510         printf("%s\n",buf);
00511 }
00512 
00513 static void print_entry_stat(
00514     char *entry_name,
00515     struct stat *attr, const char *link_target)
00516 {
00517     char buf[128] = {0}, *formatted_size = NULL;
00518     char *formatted_owner = NULL, *formatted_group = NULL;
00519     struct group *grp = NULL;
00520     struct passwd *pwd = NULL;
00521     char *empty_str = "";
00522     char *owner = empty_str, *group = empty_str;
00523     char *inode = empty_str;
00524     time_t mtime = (time_t)attr->st_mtime;
00525     struct tm *time = localtime(&mtime);
00526     unsigned long size = 0;
00527     char scratch_owner[16] = {0}, scratch_group[16] = {0};
00528     char scratch_size[16] = {0};
00529     char f_type = '-';
00530     char group_x_char = '-';
00531 
00532     if (attr == NULL)
00533     {
00534         return;
00535     }
00536 
00537     snprintf(scratch_owner,16,"%d",(int)attr->st_uid);
00538     snprintf(scratch_group,16,"%d",(int)attr->st_gid);
00539 
00540     if (S_ISREG(attr->st_mode))
00541     {
00542         size = attr->st_size;
00543     }
00544     else if (S_ISLNK(attr->st_mode))
00545     {
00546         size = 0;
00547     }
00548     else if (S_ISDIR(attr->st_mode))
00549     {
00550         size = 4096;
00551     }
00552 
00553           snprintf(scratch_size,16, "%ld", size);
00554     format_size_string(scratch_size,11,&formatted_size,1,1);
00555 
00556           owner = scratch_owner;
00557           group = scratch_group;
00558 
00559             pwd = getpwuid((uid_t)attr->st_uid);
00560             owner = (pwd ? pwd->pw_name : scratch_owner);
00561             grp = getgrgid((gid_t)attr->st_gid);
00562             group = (grp ? grp->gr_name : scratch_group);
00563 
00564     /* for owner and group allow the fields to grow larger than 8 if
00565      * necessary (set hard_limit to 0), but pad anything smaller to
00566      * take up 8 spaces.
00567      */
00568     format_size_string(owner,8,&formatted_owner,0,0);
00569     format_size_string(group,8,&formatted_group,0,0);
00570 
00571     if (S_ISDIR(attr->st_mode))
00572     {
00573         f_type =  'd';
00574     }
00575     else if (S_ISLNK(attr->st_mode))
00576     {
00577         f_type =  'l';
00578     }
00579 
00580          if (link_target == NULL)
00581     snprintf(buf,128,"%s%c%c%c%c%c%c%c%c%c%c    1 %s %s %s "
00582              "%.4d-%.2d-%.2d %.2d:%.2d %s",
00583              inode,
00584              f_type,
00585              ((attr->st_mode & S_IRUSR) ? 'r' : '-'),
00586              ((attr->st_mode & S_IWUSR) ? 'w' : '-'),
00587              ((attr->st_mode & S_IXUSR) ? 'x' : '-'),
00588              ((attr->st_mode & S_IRGRP) ? 'r' : '-'),
00589              ((attr->st_mode & S_IWGRP) ? 'w' : '-'),
00590              group_x_char,
00591              ((attr->st_mode & S_IROTH) ? 'r' : '-'),
00592              ((attr->st_mode & S_IWOTH) ? 'w' : '-'),
00593              ((attr->st_mode & S_IXOTH) ? 'x' : '-'),
00594              formatted_owner,
00595              formatted_group,
00596              formatted_size,
00597              (time->tm_year + 1900),
00598              (time->tm_mon + 1),
00599              time->tm_mday,
00600              (time->tm_hour),
00601              (time->tm_min),
00602              entry_name);
00603          else
00604     snprintf(buf,128,"%s%c%c%c%c%c%c%c%c%c%c    1 %s %s %s "
00605              "%.4d-%.2d-%.2d %.2d:%.2d %s -> %s",
00606              inode,
00607              f_type,
00608              ((attr->st_mode & S_IRUSR) ? 'r' : '-'),
00609              ((attr->st_mode & S_IWUSR) ? 'w' : '-'),
00610              ((attr->st_mode & S_IXUSR) ? 'x' : '-'),
00611              ((attr->st_mode & S_IRGRP) ? 'r' : '-'),
00612              ((attr->st_mode & S_IWGRP) ? 'w' : '-'),
00613              group_x_char,
00614              ((attr->st_mode & S_IROTH) ? 'r' : '-'),
00615              ((attr->st_mode & S_IWOTH) ? 'w' : '-'),
00616              ((attr->st_mode & S_IXOTH) ? 'x' : '-'),
00617              formatted_owner,
00618              formatted_group,
00619              formatted_size,
00620              (time->tm_year + 1900),
00621              (time->tm_mon + 1),
00622              time->tm_mday,
00623              (time->tm_hour),
00624              (time->tm_min),
00625              entry_name, link_target);
00626 
00627 
00628     if (formatted_size)
00629     {
00630         free(formatted_size);
00631     }
00632     if (formatted_owner)
00633     {
00634         free(formatted_owner);
00635     }
00636     if (formatted_group)
00637     {
00638         free(formatted_group);
00639     }
00640          if ((use_direntplus == 0 && f_type != 'd') || use_direntplus != 0)
00641                           nobjects++;
00642         if (verbose)
00643          printf("%s\n",buf);
00644 }
00645 
00646 static void print_entry_kernel_stat(
00647     char *entry_name,
00648     struct kernel_stat *attr, const char *link_target)
00649 {
00650     char buf[128] = {0}, *formatted_size = NULL;
00651     char *formatted_owner = NULL, *formatted_group = NULL;
00652     struct group *grp = NULL;
00653     struct passwd *pwd = NULL;
00654     char *empty_str = "";
00655     char *owner = empty_str, *group = empty_str;
00656     char *inode = empty_str;
00657     time_t mtime = (time_t)attr->st_mtim;
00658     struct tm *time = localtime(&mtime);
00659     unsigned long size = 0;
00660     char scratch_owner[16] = {0}, scratch_group[16] = {0};
00661     char scratch_size[16] = {0};
00662     char f_type = '-';
00663     char group_x_char = '-';
00664 
00665     if (attr == NULL)
00666     {
00667         return;
00668     }
00669 
00670     snprintf(scratch_owner,16,"%d",(int)attr->st_uid);
00671     snprintf(scratch_group,16,"%d",(int)attr->st_gid);
00672 
00673     if (S_ISREG(attr->st_mode))
00674     {
00675         size = attr->st_size;
00676     }
00677     else if (S_ISLNK(attr->st_mode))
00678     {
00679         size = 0;
00680     }
00681     else if (S_ISDIR(attr->st_mode))
00682     {
00683         size = 4096;
00684     }
00685 
00686           snprintf(scratch_size,16, "%ld", size);
00687     format_size_string(scratch_size,11,&formatted_size,1,1);
00688 
00689           owner = scratch_owner;
00690           group = scratch_group;
00691 
00692             pwd = getpwuid((uid_t)attr->st_uid);
00693             owner = (pwd ? pwd->pw_name : scratch_owner);
00694             grp = getgrgid((gid_t)attr->st_gid);
00695             group = (grp ? grp->gr_name : scratch_group);
00696 
00697     /* for owner and group allow the fields to grow larger than 8 if
00698      * necessary (set hard_limit to 0), but pad anything smaller to
00699      * take up 8 spaces.
00700      */
00701     format_size_string(owner,8,&formatted_owner,0,0);
00702     format_size_string(group,8,&formatted_group,0,0);
00703 
00704     if (S_ISDIR(attr->st_mode))
00705     {
00706         f_type =  'd';
00707     }
00708     else if (S_ISLNK(attr->st_mode))
00709     {
00710         f_type =  'l';
00711     }
00712 
00713          if (link_target == NULL)
00714     snprintf(buf,128,"%s%c%c%c%c%c%c%c%c%c%c    1 %s %s %s "
00715              "%.4d-%.2d-%.2d %.2d:%.2d %s",
00716              inode,
00717              f_type,
00718              ((attr->st_mode & S_IRUSR) ? 'r' : '-'),
00719              ((attr->st_mode & S_IWUSR) ? 'w' : '-'),
00720              ((attr->st_mode & S_IXUSR) ? 'x' : '-'),
00721              ((attr->st_mode & S_IRGRP) ? 'r' : '-'),
00722              ((attr->st_mode & S_IWGRP) ? 'w' : '-'),
00723              group_x_char,
00724              ((attr->st_mode & S_IROTH) ? 'r' : '-'),
00725              ((attr->st_mode & S_IWOTH) ? 'w' : '-'),
00726              ((attr->st_mode & S_IXOTH) ? 'x' : '-'),
00727              formatted_owner,
00728              formatted_group,
00729              formatted_size,
00730              (time->tm_year + 1900),
00731              (time->tm_mon + 1),
00732              time->tm_mday,
00733              (time->tm_hour),
00734              (time->tm_min),
00735              entry_name);
00736          else
00737     snprintf(buf,128,"%s%c%c%c%c%c%c%c%c%c%c    1 %s %s %s "
00738              "%.4d-%.2d-%.2d %.2d:%.2d %s -> %s",
00739              inode,
00740              f_type,
00741              ((attr->st_mode & S_IRUSR) ? 'r' : '-'),
00742              ((attr->st_mode & S_IWUSR) ? 'w' : '-'),
00743              ((attr->st_mode & S_IXUSR) ? 'x' : '-'),
00744              ((attr->st_mode & S_IRGRP) ? 'r' : '-'),
00745              ((attr->st_mode & S_IWGRP) ? 'w' : '-'),
00746              group_x_char,
00747              ((attr->st_mode & S_IROTH) ? 'r' : '-'),
00748              ((attr->st_mode & S_IWOTH) ? 'w' : '-'),
00749              ((attr->st_mode & S_IXOTH) ? 'x' : '-'),
00750              formatted_owner,
00751              formatted_group,
00752              formatted_size,
00753              (time->tm_year + 1900),
00754              (time->tm_mon + 1),
00755              time->tm_mday,
00756              (time->tm_hour),
00757              (time->tm_min),
00758              entry_name, link_target);
00759 
00760     if (formatted_size)
00761     {
00762         free(formatted_size);
00763     }
00764     if (formatted_owner)
00765     {
00766         free(formatted_owner);
00767     }
00768     if (formatted_group)
00769     {
00770         free(formatted_group);
00771     }
00772          if ((use_direntplus == 0 && f_type != 'd') || use_direntplus != 0)
00773                           nobjects++;
00774         if (verbose)
00775         printf("%s\n",buf);
00776 }
00777 
00778 static void print_entry_kernel_stat_lite(
00779     char *entry_name,
00780     struct kernel_stat_lite *attr, const char *link_target)
00781 {
00782     char buf[128] = {0};
00783     char *formatted_owner = NULL, *formatted_group = NULL;
00784     struct group *grp = NULL;
00785     struct passwd *pwd = NULL;
00786     char *empty_str = "";
00787     char *owner = empty_str, *group = empty_str;
00788     char *inode = empty_str;
00789     time_t mtime = (time_t)attr->st_mtim;
00790     struct tm *time = localtime(&mtime);
00791     char scratch_owner[16] = {0}, scratch_group[16] = {0};
00792     char f_type = '-';
00793     char group_x_char = '-';
00794 
00795     if (attr == NULL)
00796     {
00797         return;
00798     }
00799 
00800     snprintf(scratch_owner,16,"%d",(int)attr->st_uid);
00801     snprintf(scratch_group,16,"%d",(int)attr->st_gid);
00802 
00803           owner = scratch_owner;
00804           group = scratch_group;
00805 
00806             pwd = getpwuid((uid_t)attr->st_uid);
00807             owner = (pwd ? pwd->pw_name : scratch_owner);
00808             grp = getgrgid((gid_t)attr->st_gid);
00809             group = (grp ? grp->gr_name : scratch_group);
00810 
00811     /* for owner and group allow the fields to grow larger than 8 if
00812      * necessary (set hard_limit to 0), but pad anything smaller to
00813      * take up 8 spaces.
00814      */
00815     format_size_string(owner,8,&formatted_owner,0,0);
00816     format_size_string(group,8,&formatted_group,0,0);
00817 
00818     if (S_ISDIR(attr->st_mode))
00819     {
00820         f_type =  'd';
00821     }
00822     else if (S_ISLNK(attr->st_mode))
00823     {
00824         f_type =  'l';
00825     }
00826 
00827          if (link_target == NULL)
00828     snprintf(buf,128,"%s%c%c%c%c%c%c%c%c%c%c    1 %s %s "
00829              "%.4d-%.2d-%.2d %.2d:%.2d %s",
00830              inode,
00831              f_type,
00832              ((attr->st_mode & S_IRUSR) ? 'r' : '-'),
00833              ((attr->st_mode & S_IWUSR) ? 'w' : '-'),
00834              ((attr->st_mode & S_IXUSR) ? 'x' : '-'),
00835              ((attr->st_mode & S_IRGRP) ? 'r' : '-'),
00836              ((attr->st_mode & S_IWGRP) ? 'w' : '-'),
00837              group_x_char,
00838              ((attr->st_mode & S_IROTH) ? 'r' : '-'),
00839              ((attr->st_mode & S_IWOTH) ? 'w' : '-'),
00840              ((attr->st_mode & S_IXOTH) ? 'x' : '-'),
00841              formatted_owner,
00842              formatted_group,
00843              (time->tm_year + 1900),
00844              (time->tm_mon + 1),
00845              time->tm_mday,
00846              (time->tm_hour),
00847              (time->tm_min),
00848              entry_name);
00849          else
00850     snprintf(buf,128,"%s%c%c%c%c%c%c%c%c%c%c    1 %s %s "
00851              "%.4d-%.2d-%.2d %.2d:%.2d %s -> %s",
00852              inode,
00853              f_type,
00854              ((attr->st_mode & S_IRUSR) ? 'r' : '-'),
00855              ((attr->st_mode & S_IWUSR) ? 'w' : '-'),
00856              ((attr->st_mode & S_IXUSR) ? 'x' : '-'),
00857              ((attr->st_mode & S_IRGRP) ? 'r' : '-'),
00858              ((attr->st_mode & S_IWGRP) ? 'w' : '-'),
00859              group_x_char,
00860              ((attr->st_mode & S_IROTH) ? 'r' : '-'),
00861              ((attr->st_mode & S_IWOTH) ? 'w' : '-'),
00862              ((attr->st_mode & S_IXOTH) ? 'x' : '-'),
00863              formatted_owner,
00864              formatted_group,
00865              (time->tm_year + 1900),
00866              (time->tm_mon + 1),
00867              time->tm_mday,
00868              (time->tm_hour),
00869              (time->tm_min),
00870              entry_name, link_target);
00871 
00872     if (formatted_owner)
00873     {
00874         free(formatted_owner);
00875     }
00876     if (formatted_group)
00877     {
00878         free(formatted_group);
00879     }
00880          if ((use_direntplus == 0 && f_type != 'd') || use_direntplus != 0)
00881                                 nobjects++;
00882     if (verbose)
00883           printf("%s\n",buf);
00884 }
00885 
00886 static void print_entry_stat64_lite(
00887     char *entry_name,
00888     struct stat64_lite *attr, const char *link_target)
00889 {
00890     char buf[128] = {0};
00891     char *formatted_owner = NULL, *formatted_group = NULL;
00892     struct group *grp = NULL;
00893     struct passwd *pwd = NULL;
00894     char *empty_str = "";
00895     char *owner = empty_str, *group = empty_str;
00896     char *inode = empty_str;
00897     time_t mtime = (time_t)attr->st_mtim;
00898     struct tm *time = localtime(&mtime);
00899     char scratch_owner[16] = {0}, scratch_group[16] = {0};
00900     char f_type = '-';
00901     char group_x_char = '-';
00902 
00903     if (attr == NULL)
00904     {
00905         return;
00906     }
00907 
00908     snprintf(scratch_owner,16,"%d",(int)attr->st_uid);
00909     snprintf(scratch_group,16,"%d",(int)attr->st_gid);
00910 
00911           owner = scratch_owner;
00912           group = scratch_group;
00913 
00914             pwd = getpwuid((uid_t)attr->st_uid);
00915             owner = (pwd ? pwd->pw_name : scratch_owner);
00916             grp = getgrgid((gid_t)attr->st_gid);
00917             group = (grp ? grp->gr_name : scratch_group);
00918 
00919     /* for owner and group allow the fields to grow larger than 8 if
00920      * necessary (set hard_limit to 0), but pad anything smaller to
00921      * take up 8 spaces.
00922      */
00923     format_size_string(owner,8,&formatted_owner,0,0);
00924     format_size_string(group,8,&formatted_group,0,0);
00925 
00926     if (S_ISDIR(attr->st_mode))
00927     {
00928         f_type =  'd';
00929     }
00930     else if (S_ISLNK(attr->st_mode))
00931     {
00932         f_type =  'l';
00933     }
00934 
00935          if (link_target == NULL)
00936     snprintf(buf,128,"%s%c%c%c%c%c%c%c%c%c%c    1 %s %s "
00937              "%.4d-%.2d-%.2d %.2d:%.2d %s",
00938              inode,
00939              f_type,
00940              ((attr->st_mode & S_IRUSR) ? 'r' : '-'),
00941              ((attr->st_mode & S_IWUSR) ? 'w' : '-'),
00942              ((attr->st_mode & S_IXUSR) ? 'x' : '-'),
00943              ((attr->st_mode & S_IRGRP) ? 'r' : '-'),
00944              ((attr->st_mode & S_IWGRP) ? 'w' : '-'),
00945              group_x_char,
00946              ((attr->st_mode & S_IROTH) ? 'r' : '-'),
00947              ((attr->st_mode & S_IWOTH) ? 'w' : '-'),
00948              ((attr->st_mode & S_IXOTH) ? 'x' : '-'),
00949              formatted_owner,
00950              formatted_group,
00951              (time->tm_year + 1900),
00952              (time->tm_mon + 1),
00953              time->tm_mday,
00954              (time->tm_hour),
00955              (time->tm_min),
00956              entry_name);
00957          else
00958     snprintf(buf,128,"%s%c%c%c%c%c%c%c%c%c%c    1 %s %s "
00959              "%.4d-%.2d-%.2d %.2d:%.2d %s -> %s",
00960              inode,
00961              f_type,
00962              ((attr->st_mode & S_IRUSR) ? 'r' : '-'),
00963              ((attr->st_mode & S_IWUSR) ? 'w' : '-'),
00964              ((attr->st_mode & S_IXUSR) ? 'x' : '-'),
00965              ((attr->st_mode & S_IRGRP) ? 'r' : '-'),
00966              ((attr->st_mode & S_IWGRP) ? 'w' : '-'),
00967              group_x_char,
00968              ((attr->st_mode & S_IROTH) ? 'r' : '-'),
00969              ((attr->st_mode & S_IWOTH) ? 'w' : '-'),
00970              ((attr->st_mode & S_IXOTH) ? 'x' : '-'),
00971              formatted_owner,
00972              formatted_group,
00973              (time->tm_year + 1900),
00974              (time->tm_mon + 1),
00975              time->tm_mday,
00976              (time->tm_hour),
00977              (time->tm_min),
00978              entry_name, link_target);
00979 
00980     if (formatted_owner)
00981     {
00982         free(formatted_owner);
00983     }
00984     if (formatted_group)
00985     {
00986         free(formatted_group);
00987     }
00988          if ((use_direntplus == 0 && f_type != 'd') || use_direntplus != 0)
00989                                 nobjects++;
00990     if (verbose)
00991           printf("%s\n",buf);
00992 }
00993 
00994 
00995 /*
00996  * Notes: We don't follow symbolic links, and we ignore any special
00997  * files like sockets, pipes etc that may be residing on this file
00998  * system. Hence, the hierarchy will be a directed acyclic tree!.
00999  * Thus, the traversal becomes much simpler than that of a complex graph.
01000  */
01001 static int path_walk(struct files *root_filp)
01002 {
01003         int dir_fd, ret;
01004         struct files *filp;
01005         struct stat statbuf;
01006         struct stat64 stat64buf;
01007         struct kernel_stat_lite statbuflite;
01008         static int invoke_count = 0;
01009         int is_dir, is_link;
01010         char link_target[NAME_MAX], *lnk = NULL;
01011 
01012         invoke_count++;
01013         ret = 0;
01014         memset(&statbuf, 0, sizeof(statbuf));
01015         /* Dequeue from the list of to-be-visited nodes */
01016         qlist_del(&root_filp->level);
01017 
01018         dir_fd = open(root_filp->name, O_RDONLY | O_NOFOLLOW);
01019         
01020         if (dir_fd < 0) {
01021                 /* lets just stat the file here, it might be some sort 
01022                  * of stale or special file or symbolic link 
01023                  */
01024                 if (use_64) 
01025                 {
01026                         if (use_lite)
01027                         {
01028                                 statbuflite.st_litemask = S_SLITE_ATIME | 
01029                                                                                  S_SLITE_MTIME |
01030                                                                                  S_SLITE_CTIME |
01031                                                                                  S_SLITE_BLKSIZE |
01032                                                                                  S_SLITE_BLOCKS;
01033                                 ret = syscall(__NR_newlstatlite, root_filp->name, &statbuflite);
01034                                 is_dir = S_ISDIR(statbuflite.st_mode);
01035                                 is_link = S_ISLNK(statbuflite.st_mode);
01036                         }
01037                         else
01038                         {
01039                                 ret = lstat64(root_filp->name, &stat64buf);
01040                                 is_dir = S_ISDIR(stat64buf.st_mode);
01041                                 is_link = S_ISLNK(stat64buf.st_mode);
01042                         }
01043                 }
01044                 else {
01045                         if (use_lite)
01046                         {
01047                                 statbuflite.st_litemask = S_SLITE_ATIME | 
01048                                                                                  S_SLITE_MTIME |
01049                                                                                  S_SLITE_CTIME |
01050                                                                                  S_SLITE_BLKSIZE |
01051                                                                                  S_SLITE_BLOCKS;
01052                                 ret = syscall(__NR_newlstatlite, root_filp->name, &statbuflite);
01053                                 is_dir = S_ISDIR(statbuflite.st_mode);
01054                                 is_link = S_ISLNK(statbuflite.st_mode);
01055                         }
01056                         else 
01057                         {
01058                                 ret = lstat(root_filp->name, &statbuf);
01059                                 is_dir = S_ISDIR(statbuf.st_mode);
01060                                 is_link = S_ISLNK(statbuf.st_mode);
01061                         }
01062                 }
01063         }
01064         else {
01065                 if (use_64) 
01066                 {
01067                         if (use_lite)
01068                         {
01069                                 statbuflite.st_litemask = S_SLITE_ATIME | 
01070                                                                                  S_SLITE_MTIME |
01071                                                                                  S_SLITE_CTIME |
01072                                                                                  S_SLITE_BLKSIZE |
01073                                                                                  S_SLITE_BLOCKS;
01074                                 ret = syscall(__NR_newfstatlite,dir_fd, &statbuflite);
01075                                 is_dir = S_ISDIR(statbuflite.st_mode);
01076                                 is_link = S_ISLNK(statbuflite.st_mode);
01077                         }
01078                         else
01079                         {
01080                                 ret = fstat64(dir_fd, &stat64buf);
01081                                 is_dir = S_ISDIR(stat64buf.st_mode);
01082                                 is_link = S_ISLNK(stat64buf.st_mode);
01083                         }
01084                 }
01085                 else 
01086                 {
01087                         if (use_lite)
01088                         {
01089                                 statbuflite.st_litemask = S_SLITE_ATIME | 
01090                                                                                  S_SLITE_MTIME |
01091                                                                                  S_SLITE_CTIME |
01092                                                                                  S_SLITE_BLKSIZE |
01093                                                                                  S_SLITE_BLOCKS;
01094                                 ret = syscall(__NR_newfstatlite, dir_fd, &statbuflite);
01095                                 is_dir = S_ISDIR(statbuflite.st_mode);
01096                                 is_link = S_ISLNK(statbuflite.st_mode);
01097                         }
01098                         else
01099                         {
01100                                 ret = fstat(dir_fd, &statbuf);
01101                                 is_dir = S_ISDIR(statbuf.st_mode);
01102                                 is_link = S_ISLNK(statbuf.st_mode);
01103                         }
01104                 }
01105         }
01106         if (ret < 0)
01107                 goto err;
01108         nlevels = root_filp->visited;
01109         /* Are we looking at a directory? */
01110         if (is_dir) 
01111         {
01112                 if (use_direntplus == 0)
01113                           nobjects++;
01114                 /* Use plain old getdents interface */
01115                 if (dir_fd >= 0 && use_direntplus == 0) 
01116                 {
01117                         struct dirent64 *p64 = NULL, *next64;
01118                         struct dirent *p = NULL, *next;
01119                         int dirent_input_count = dirent_granularity, counter = 1;
01120                         long total_rec_len, i, dirent_total_count = 0, dirent_output_bytes, dirent_total_bytes = 0;
01121                         char *ptr = NULL;
01122 
01123                         if (invoke_count > 1 && recurse == 0) {
01124                                 ret = 0;
01125                                 if (use_64) {
01126                                         if (use_lite)
01127                                                 print_entry_kernel_stat_lite(root_filp->name, &statbuflite, NULL);
01128                                         else
01129                                                 print_entry_stat64(root_filp->name, &stat64buf, NULL);
01130                                 }
01131                                 else {
01132                                         if (use_lite)
01133                                                 print_entry_kernel_stat_lite(root_filp->name, &statbuflite, NULL);
01134                                         else
01135                                                 print_entry_stat(root_filp->name, &statbuf, NULL);
01136                                 }
01137                                 goto err;
01138                         }
01139 
01140                         lseek(dir_fd, 0, SEEK_SET);
01141                         do {
01142                                 if (use_64)
01143                                 {
01144                                         if (dirent_total_bytes >= (dirent_input_count * (counter - 1) * sizeof(struct dirent64)))
01145                                         {
01146                                                 p64 = (struct dirent64 *) realloc(p64, 
01147                                                                 (dirent_input_count * counter++) * sizeof(struct dirent64));
01148                                                 assert(p64);
01149                                         }
01150                                         ptr = (char *) p64 + dirent_total_bytes;
01151                                         dirent_output_bytes = syscall(__NR_getdents64, dir_fd, 
01152                                                                                  (struct dirent64 *) ptr, 
01153                                                                                  dirent_input_count * sizeof(struct dirent64));
01154                                         if (dirent_output_bytes <= 0)
01155                                                 break;
01156                                         total_rec_len = 0;
01157                                         dirent_total_bytes += dirent_output_bytes;
01158                                         while (total_rec_len < dirent_output_bytes) {
01159                                                 next64 = (struct dirent64 *) (ptr + total_rec_len);
01160                                                 total_rec_len += next64->d_reclen;
01161                                                 dirent_total_count++;
01162                                         }
01163                                 }
01164                                 else {
01165                                         if (dirent_total_bytes >= (dirent_input_count * (counter - 1) * sizeof(struct dirent)))
01166                                         {
01167                                                 p = (struct dirent *) realloc(p, 
01168                                                                 (dirent_input_count * counter++) * sizeof(struct dirent));
01169                                                 assert(p);
01170                                         }
01171                                         ptr = (char *) p + dirent_total_bytes;
01172                                         dirent_output_bytes = syscall(__NR_getdents, dir_fd, 
01173                                                                                  (struct dirent *) ptr, 
01174                                                                                  dirent_input_count * sizeof(struct dirent));
01175                                         if (dirent_output_bytes <= 0)
01176                                                 break;
01177                                         total_rec_len = 0;
01178                                         dirent_total_bytes += dirent_output_bytes;
01179                                         while (total_rec_len < dirent_output_bytes) {
01180                                                 next = (struct dirent *) (ptr + total_rec_len);
01181                                                 total_rec_len += next->d_reclen;
01182                                                 dirent_total_count++;
01183                                         }
01184                                 }
01185                         } while (1);
01186                         if (dirent_output_bytes < 0) {
01187                                 perror("getdents/getdents64");
01188                                 goto err;
01189                         }
01190                         if (use_64)
01191                                 ptr = (char *) p64;
01192                         else
01193                                 ptr = (char *) p;
01194                         total_rec_len = 0;
01195                         for (i = 0; i < dirent_total_count; i++) 
01196                         {
01197                                 if (use_64)
01198                                 {
01199                                         next64 = (struct dirent64 *) (ptr + total_rec_len);
01200                                         total_rec_len += next64->d_reclen;
01201                                         /* As long as it is not . or .. recurse */
01202                                         if (strcmp(next64->d_name, ".") && strcmp(next64->d_name, "..")) 
01203                                         {
01204                                                 filp = (struct files *)calloc(1, sizeof(struct files));
01205                                                 if (!filp) {
01206                                                         perror("do_root:calloc");
01207                                                         return -1;
01208                                                 }
01209                                                 snprintf(filp->name, NAME_MAX + 1, "%s/%s", root_filp->name, next64->d_name);
01210                                                 /* Add to the tree */
01211                                                 qlist_add_tail(&filp->level, &TREE);
01212                                                 filp->visited = root_filp->visited + 1;
01213                                         }
01214                                 }
01215                                 else {
01216                                         next = (struct dirent *) (ptr + total_rec_len);
01217                                         total_rec_len += next->d_reclen;
01218                                         /* As long as it is not . or .. recurse */
01219                                         if (strcmp(next->d_name, ".") && strcmp(next->d_name, "..")) 
01220                                         {
01221                                                 filp = (struct files *)calloc(1, sizeof(struct files));
01222                                                 if (!filp) {
01223                                                         perror("do_root:calloc");
01224                                                         return -1;
01225                                                 }
01226                                                 snprintf(filp->name, NAME_MAX + 1, "%s/%s", root_filp->name, next->d_name);
01227                                                 /* Add to the tree */
01228                                                 qlist_add_tail(&filp->level, &TREE);
01229                                                 filp->visited = root_filp->visited + 1;
01230                                         }
01231                                 }
01232                         }
01233                         if (use_64)
01234                                 free(p64);
01235                         else
01236                                 free(p);
01237                 }
01238                 /* Use the new fangled 64 bit interface */
01239                 else if (dir_fd >= 0 && use_direntplus == 1)
01240                 {
01241                         struct dirent64_plus *p64 = NULL, *next64;
01242                         struct dirent_plus *p = NULL, *next = NULL;
01243                         int dirent_input_count = dirent_granularity, counter = 1;
01244                         int total_rec_len, i, dirent_total_count = 0, dirent_output_bytes, dirent_total_bytes = 0;
01245                         char *ptr = NULL, fname[NAME_MAX];
01246                         struct dirent_plus_lite *p_lite = NULL, *next_lite = NULL;
01247                         struct dirent64_plus_lite *p64_lite = NULL, *next64_lite = NULL;
01248                         unsigned long lite_mask = S_SLITE_ATIME | S_SLITE_MTIME | S_SLITE_CTIME | S_SLITE_BLKSIZE | S_SLITE_BLOCKS;
01249 
01250                         lseek(dir_fd, 0, SEEK_SET);
01251                         do {
01252                                 if (use_64)
01253                                 {
01254                                         if (use_lite)
01255                                         {
01256                                                 if (dirent_total_bytes >= (dirent_input_count * (counter - 1) * sizeof(struct dirent64_plus_lite)))
01257                                                 {
01258                                                         p64_lite = (struct dirent64_plus_lite *) realloc(p64_lite, 
01259                                                                         (dirent_input_count * counter++) * sizeof(struct dirent64_plus_lite));
01260                                                         assert(p64_lite);
01261                                                 }
01262                                                 ptr = (char *) p64_lite + dirent_total_bytes;
01263                                                 dirent_output_bytes = syscall(__NR_getdents64_plus_lite, 
01264                                                                                          dir_fd, lite_mask, 
01265                                                                                          (struct dirent64_plus_lite *) ptr, 
01266                                                                                          dirent_input_count * sizeof(struct dirent64_plus_lite));
01267                                                 if (dirent_output_bytes <= 0)
01268                                                         break;
01269                                                 total_rec_len = 0;
01270                                                 dirent_total_bytes += dirent_output_bytes;
01271                                                 while (total_rec_len < dirent_output_bytes) {
01272                                                         next64_lite = (struct dirent64_plus_lite *) (ptr + total_rec_len);
01273                                                         total_rec_len += next64_lite->dp_dirent.d_reclen;
01274                                                         dirent_total_count++;
01275                                                 }
01276                                         }
01277                                         else 
01278                                         {
01279                                                 if (dirent_total_bytes >= (dirent_input_count * (counter - 1) * sizeof(struct dirent64_plus)))
01280                                                 {
01281                                                         p64 = (struct dirent64_plus *) realloc(p64, 
01282                                                                         (dirent_input_count * counter++) * sizeof(struct dirent64_plus));
01283                                                         assert(p64);
01284                                                 }
01285                                                 ptr = (char *) p64 + dirent_total_bytes;
01286                                                 dirent_output_bytes = syscall(__NR_getdents64_plus, dir_fd, 
01287                                                                                          (struct dirent64_plus *) ptr, 
01288                                                                                          dirent_input_count * sizeof(struct dirent64_plus));
01289                                                 if (dirent_output_bytes <= 0)
01290                                                         break;
01291                                                 total_rec_len = 0;
01292                                                 dirent_total_bytes += dirent_output_bytes;
01293                                                 while (total_rec_len < dirent_output_bytes) {
01294                                                         next64 = (struct dirent64_plus *) (ptr + total_rec_len);
01295                                                         total_rec_len += next64->dp_dirent.d_reclen;
01296                                                         dirent_total_count++;
01297                                                 }
01298                                         }
01299                                 }
01300                                 else 
01301                                 {
01302                                         if (use_lite)
01303                                         {
01304                                                 if (dirent_total_bytes >= (dirent_input_count * (counter - 1) * sizeof(struct dirent_plus_lite)))
01305                                                 {
01306                                                         p_lite = (struct dirent_plus_lite *) realloc(p_lite,
01307                                                                         (dirent_input_count * counter++) * sizeof(struct dirent_plus_lite));
01308                                                         assert(p_lite);
01309                                                 }
01310                                                 ptr = (char *) p_lite + dirent_total_bytes;
01311                                                 dirent_output_bytes = syscall(__NR_getdents_plus_lite, 
01312                                                                                          dir_fd, lite_mask, 
01313                                                                                          (struct dirent_plus_lite *) ptr, 
01314                                                                                          dirent_input_count * sizeof(struct dirent_plus_lite));
01315                                                 if (dirent_output_bytes <= 0)
01316                                                         break;
01317                                                 total_rec_len = 0;
01318                                                 dirent_total_bytes += dirent_output_bytes;
01319                                                 while (total_rec_len < dirent_output_bytes) {
01320                                                         next_lite = (struct dirent_plus_lite *) (ptr + total_rec_len);
01321                                                         total_rec_len += next_lite->dp_dirent.d_reclen;
01322                                                         dirent_total_count++;
01323                                                 }
01324                                         }
01325                                         else
01326                                         {
01327                                                 if (dirent_total_bytes >= (dirent_input_count * (counter - 1) * sizeof(struct dirent_plus)))
01328                                                 {
01329                                                         p = (struct dirent_plus *) realloc(p,
01330                                                                         (dirent_input_count * counter++) * sizeof(struct dirent_plus));
01331                                                         assert(p);
01332                                                 }
01333                                                 ptr = (char *) p + dirent_total_bytes;
01334                                                 dirent_output_bytes = syscall(__NR_getdents_plus, dir_fd, 
01335                                                                 (struct dirent_plus *) ptr, 
01336                                                                 dirent_input_count * sizeof(struct dirent_plus));
01337                                                 if (dirent_output_bytes <= 0)
01338                                                         break;
01339                                                 total_rec_len = 0;
01340                                                 dirent_total_bytes += dirent_output_bytes;
01341                                                 while (total_rec_len < dirent_output_bytes) {
01342                                                         next = (struct dirent_plus *) (ptr + total_rec_len);
01343                                                         total_rec_len += next->dp_dirent.d_reclen;
01344                                                         dirent_total_count++;
01345                                                 }
01346                                         }
01347                                 }
01348                         } while (1);
01349                         if (dirent_output_bytes < 0) {
01350                                 perror("getdents_plus/getdents64_plus");
01351                                 goto err;
01352                         }
01353                         if (use_64)
01354                                 ptr = (use_lite) ? (char *) p64_lite : (char *) p64;
01355                         else
01356                         {
01357                                 ptr = (use_lite) ? (char *) p_lite : (char *) p;
01358                         }
01359                         total_rec_len = 0;
01360                         for (i = 0; i < dirent_total_count; i++) 
01361                         {
01362                                 if (use_64)
01363                                 {
01364                                         if (use_lite)
01365                                         {
01366                                                 next64_lite = (struct dirent64_plus_lite *) (ptr + total_rec_len);
01367                                                 total_rec_len += next64_lite->dp_dirent.d_reclen;
01368                                                 /* As long as it is not . or .. recurse */
01369                                                 if (strcmp(next64_lite->dp_dirent.d_name, ".") && strcmp(next64_lite->dp_dirent.d_name, "..")) 
01370                                                 {
01371                                                         lnk = NULL;
01372                                                         snprintf(fname, NAME_MAX, "%s/%s", root_filp->name, next64_lite->dp_dirent.d_name);
01373                                                         if (S_ISLNK(next64_lite->dp_stat_lite.st_mode))
01374                                                         {
01375                                                                 readlink(fname, link_target, NAME_MAX);
01376                                                                 lnk = link_target;
01377                                                         }
01378                                                         print_entry_stat64_lite(fname, &next64_lite->dp_stat_lite, lnk);
01379                                                         if (recurse && S_ISDIR(next64_lite->dp_stat_lite.st_mode))
01380                                                         {
01381                                                                 filp = (struct files *)calloc(1, sizeof(struct files));
01382                                                                 if (!filp) {
01383                                                                         perror("do_root:calloc");
01384                                                                         return -1;
01385                                                                 }
01386                                                                 snprintf(filp->name, NAME_MAX + 1, "%s/%s", root_filp->name, next64_lite->dp_dirent.d_name);
01387                                                                 /* Add to the tree */
01388                                                                 qlist_add_tail(&filp->level, &TREE);
01389                                                                 filp->visited = root_filp->visited + 1;
01390                                                         }
01391                                                 }
01392                                         }
01393                                         else
01394                                         {
01395                                                 next64 = (struct dirent64_plus *) (ptr + total_rec_len);
01396                                                 total_rec_len += next64->dp_dirent.d_reclen;
01397                                                 /* As long as it is not . or .. recurse */
01398                                                 if (strcmp(next64->dp_dirent.d_name, ".") && strcmp(next64->dp_dirent.d_name, "..")) 
01399                                                 {
01400                                                         lnk = NULL;
01401                                                         snprintf(fname, NAME_MAX, "%s/%s", root_filp->name, next64->dp_dirent.d_name);
01402                                                         if (S_ISLNK(next64->dp_stat.st_mode))
01403                                                         {
01404                                                                 readlink(fname, link_target, NAME_MAX);
01405                                                                 lnk = link_target;
01406                                                         }
01407 #if defined(__i386__) || defined(__i486__) || defined(__i586__) || defined(__i686__)
01408                                                         print_entry_stat64(fname, &next64->dp_stat, lnk);
01409 #elif defined (x86_64) || defined (__x86_64__)
01410                                                         print_entry_kernel_stat(fname, &next64->dp_stat, lnk);
01411 #endif
01412                                                         if (recurse && S_ISDIR(next64->dp_stat.st_mode))
01413                                                         {
01414                                                                 filp = (struct files *)calloc(1, sizeof(struct files));
01415                                                                 if (!filp) {
01416                                                                         perror("do_root:calloc");
01417                                                                         return -1;
01418                                                                 }
01419                                                                 snprintf(filp->name, NAME_MAX + 1, "%s/%s", root_filp->name, next64->dp_dirent.d_name);
01420                                                                 /* Add to the tree */
01421                                                                 qlist_add_tail(&filp->level, &TREE);
01422                                                                 filp->visited = root_filp->visited + 1;
01423                                                         }
01424                                                 }
01425                                         }
01426                                 }
01427                                 else 
01428                                 {
01429                                         if (use_lite)
01430                                         {
01431                                                 next_lite = (struct dirent_plus_lite *) (ptr + total_rec_len);
01432                                                 total_rec_len += next_lite->dp_dirent.d_reclen;
01433                                                 /* As long as it is not . or .. recurse */
01434                                                 if (strcmp(next_lite->dp_dirent.d_name, ".") && strcmp(next_lite->dp_dirent.d_name, "..")) 
01435                                                 {
01436                                                         lnk = NULL;
01437                                                         snprintf(fname, NAME_MAX, "%s/%s", root_filp->name, next_lite->dp_dirent.d_name);
01438                                                         if (S_ISLNK(next_lite->dp_stat_lite.st_mode))
01439                                                         {
01440                                                                 readlink(fname, link_target, NAME_MAX);
01441                                                                 lnk = link_target;
01442                                                         }
01443                                                         print_entry_kernel_stat_lite(fname, &next_lite->dp_stat_lite, lnk);
01444                                                         if (recurse && S_ISDIR(next_lite->dp_stat_lite.st_mode))
01445                                                         {
01446                                                                 filp = (struct files *)calloc(1, sizeof(struct files));
01447                                                                 if (!filp) {
01448                                                                         perror("do_root:calloc");
01449                                                                         return -1;
01450                                                                 }
01451                                                                 snprintf(filp->name, NAME_MAX + 1, "%s/%s", root_filp->name, next_lite->dp_dirent.d_name);
01452                                                                 /* Add to the tree */
01453                                                                 qlist_add_tail(&filp->level, &TREE);
01454                                                                 filp->visited = root_filp->visited + 1;
01455                                                         }
01456                                                 }
01457                                         }
01458                                         else
01459                                         {
01460                                                 next = (struct dirent_plus *) (ptr + total_rec_len);
01461                                                 total_rec_len += next->dp_dirent.d_reclen;
01462                                                 /* As long as it is not . or .. recurse */
01463                                                 if (strcmp(next->dp_dirent.d_name, ".") && strcmp(next->dp_dirent.d_name, "..")) 
01464                                                 {
01465                                                         lnk = NULL;
01466                                                         snprintf(fname, NAME_MAX, "%s/%s", root_filp->name, next->dp_dirent.d_name);
01467                                                         if (S_ISLNK(next->dp_stat.st_mode))
01468                                                         {
01469                                                                 readlink(fname, link_target, NAME_MAX);
01470                                                                 lnk = link_target;
01471                                                         }
01472                                                         print_entry_kernel_stat(fname, &next->dp_stat, lnk);
01473                                                         if (recurse && S_ISDIR(next->dp_stat.st_mode))
01474                                                         {
01475                                                                 filp = (struct files *)calloc(1, sizeof(struct files));
01476                                                                 if (!filp) {
01477                                                                         perror("do_root:calloc");
01478                                                                         return -1;
01479                                                                 }
01480                                                                 snprintf(filp->name, NAME_MAX + 1, "%s/%s", root_filp->name, next->dp_dirent.d_name);
01481                                                                 /* Add to the tree */
01482                                                                 qlist_add_tail(&filp->level, &TREE);
01483                                                                 filp->visited = root_filp->visited + 1;
01484                                                         }
01485                                                 }
01486                                         }
01487                                 }
01488                         }
01489                         if (use_64)
01490                         {
01491                                 if (use_lite)
01492                                         free(p64_lite);
01493                                 else
01494                                         free(p64);
01495                         }
01496                         else
01497                         {
01498                                 if (use_lite)
01499                                         free(p_lite);
01500                                 else
01501                                         free(p);
01502                         }
01503                 }
01504         }
01505         /* or are we looking at a regular file? */
01506         else {
01507                 if (use_direntplus == 0) {
01508                         if (use_64) {
01509                                 lnk = NULL;
01510                                 if (is_link)
01511                                 {
01512                                         readlink(root_filp->name, link_target, NAME_MAX);
01513                                         lnk = link_target;
01514                                 }
01515                                 if (use_lite)
01516                                         print_entry_kernel_stat_lite(root_filp->name, &statbuflite, lnk);
01517                                 else
01518                                         print_entry_stat64(root_filp->name, &stat64buf, lnk);
01519                         }
01520                         else {
01521                                 lnk = NULL;
01522                                 if (is_link)
01523                                 {
01524                                         readlink(root_filp->name, link_target, NAME_MAX);
01525                                         lnk = link_target;
01526                                 }
01527                                 if (use_lite)
01528                                         print_entry_kernel_stat_lite(root_filp->name, &statbuflite, lnk);
01529                                 else
01530                                         print_entry_stat(root_filp->name, &statbuf, lnk);
01531                         }
01532                 }
01533         } 
01534 err:
01535         /* Ignore any symbolic links, device-files, any other special files */
01536         free(root_filp);
01537         if (dir_fd > 0) close(dir_fd);
01538         return ret;
01539 }
01540 
01541 static double Wtime(void)
01542 {
01543     struct timeval t;
01544     gettimeofday(&t, NULL);
01545     return((double)t.tv_sec + (double)(t.tv_usec) * 1e-06);
01546 }
01547 
01548 static int do_flatten_hierarchy(void)
01549 {
01550         struct files *filp = NULL;
01551         double begin, end;
01552 
01553         begin = Wtime();
01554         /* traverse the tree and prune out unnecessary files and flatten the hierarchy */
01555         path_init(path);
01556         /* walk the tree */
01557         while (TREE.next != &TREE) 
01558         {
01559                 filp = (struct files *) qlist_entry(TREE.next, struct files, level);
01560                 /* Visit the node */
01561                 if (path_walk(filp) < 0) {
01562                         perror("do_flatten_hierarchy: path_walk:");
01563                         return -1;
01564                 }
01565         }
01566         end = Wtime();
01567         if (use_direntplus)
01568         {
01569                         printf("getdents_plus (lite %s) ( %d levels %d objects) took %g secs\n",
01570                                                                 use_lite ? "yes" : "no", 
01571                                                                 nlevels, nobjects, (end - begin));
01572         }
01573         else
01574         {
01575                         printf("getdents (lite %s) ( %d levels %d objects) took %g secs\n",
01576                                                                 use_lite ? "yes" : "no",
01577                                                                 nlevels - 1, nobjects - 1, (end - begin));
01578         }
01579         return 0;
01580 }
01581 
01582 static void usage(char *str)
01583 {
01584         fprintf(stderr, "Usage: %s -f <directory/file path> -n <dirent read granularity> -r {recurse} -s {use 64 bit dirent calls} -p {use direntplus interface} -v {verbose} -h {this help message}\n", str);
01585         return;
01586 }
01587 
01588 int main(int argc, char *argv[])
01589 {
01590         char c;
01591 
01592         while ((c = getopt(argc, argv, "n:f:rsphlv")) != EOF)
01593         {
01594                 switch(c) {
01595                         case 'l':
01596                                 use_lite = 1;
01597                                 break;
01598                    case 'v':
01599                       verbose = 1;
01600                       break;
01601                         case 's':
01602                                 use_64 = 1;
01603                                 break;
01604                         case 'r':
01605                                 recurse = 1;
01606                                 break;
01607                         case 'f':
01608                                 strcpy(path, optarg);
01609                                 break;
01610                         case 'p':
01611                                 use_direntplus = 1;
01612                                 break;
01613                         case 'n':
01614                                 dirent_granularity = atoi(optarg);
01615                                 break;
01616                         case 'h':
01617                         case '?':
01618                         default:
01619                                 fprintf(stderr, "Unknown option\n");
01620                                 usage(argv[0]);
01621                                 exit(1);
01622                 }
01623         }
01624         do_flatten_hierarchy();
01625         dealloc_treelist();
01626         return 0;
01627 }
01628 
01629 /*
01630  * Local variables:
01631  *  c-indent-level: 3
01632  *  c-basic-offset: 3
01633  *  tab-width: 3
01634  *
01635  * vim: ts=3
01636  * End:
01637  */ 
